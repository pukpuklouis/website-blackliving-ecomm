import { sqliteTable, AnySQLiteColumn, integer, text, numeric, foreignKey, uniqueIndex, real } from "drizzle-orm/sqlite-core"
  import { sql } from "drizzle-orm"

export const d1Migrations = sqliteTable("d1_migrations", {
	id: integer().primaryKey({ autoIncrement: true }),
	name: text(),
	appliedAt: numeric("applied_at").default(sql`(CURRENT_TIMESTAMP)`).notNull(),
});

export const accounts = sqliteTable("accounts", {
	id: text().primaryKey().notNull(),
	accountId: text("account_id").notNull(),
	providerId: text("provider_id").notNull(),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
	accessToken: text("access_token"),
	refreshToken: text("refresh_token"),
	idToken: text("id_token"),
	accessTokenExpiresAt: integer("access_token_expires_at"),
	refreshTokenExpiresAt: integer("refresh_token_expires_at"),
	scope: text(),
	password: text(),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
});

export const appointments = sqliteTable("appointments", {
	id: text().primaryKey().notNull(),
	appointmentNumber: text("appointment_number").notNull(),
	userId: text("user_id").references(() => users.id),
	customerInfo: text("customer_info").notNull(),
	storeLocation: text("store_location").notNull(),
	preferredDate: text("preferred_date").notNull(),
	preferredTime: text("preferred_time").notNull(),
	confirmedDatetime: integer("confirmed_datetime"),
	productInterest: text("product_interest").default("[]"),
	visitPurpose: text("visit_purpose").default("試躺體驗"),
	status: text().default("pending"),
	notes: text().default(""),
	adminNotes: text("admin_notes").default(""),
	staffAssigned: text("staff_assigned"),
	actualVisitTime: integer("actual_visit_time"),
	completedAt: integer("completed_at"),
	followUpRequired: integer("follow_up_required").default(false),
	followUpNotes: text("follow_up_notes").default(""),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
},
(table) => [
	uniqueIndex("appointments_appointment_number_unique").on(table.appointmentNumber),
]);

export const contacts = sqliteTable("contacts", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	email: text().notNull(),
	phone: text(),
	subject: text().notNull(),
	message: text().notNull(),
	status: text().default("new"),
	createdAt: integer("created_at"),
});

export const customerInteractions = sqliteTable("customer_interactions", {
	id: text().primaryKey().notNull(),
	customerProfileId: text("customer_profile_id").references(() => customerProfiles.id, { onDelete: "cascade" } ),
	type: text().notNull(),
	title: text().notNull(),
	description: text(),
	relatedId: text("related_id"),
	relatedType: text("related_type"),
	performedBy: text("performed_by"),
	metadata: text().default("{}"),
	createdAt: integer("created_at"),
});

export const customerProfiles = sqliteTable("customer_profiles", {
	id: text().primaryKey().notNull(),
	userId: text("user_id").references(() => users.id),
	customerNumber: text("customer_number").notNull(),
	name: text().notNull(),
	email: text().notNull(),
	phone: text().notNull(),
	birthday: text(),
	gender: text(),
	address: text(),
	shippingAddresses: text("shipping_addresses").default("[]"),
	totalSpent: real("total_spent"),
	orderCount: integer("order_count").default(0),
	avgOrderValue: real("avg_order_value"),
	lastOrderAt: integer("last_order_at"),
	lastPurchaseAt: integer("last_purchase_at"),
	firstPurchaseAt: integer("first_purchase_at"),
	favoriteCategories: text("favorite_categories").default("[]"),
	purchaseHistory: text("purchase_history").default("[]"),
	segment: text().default("new"),
	lifetimeValue: real("lifetime_value"),
	churnRisk: text("churn_risk").default("low"),
	lastContactAt: integer("last_contact_at"),
	contactPreference: text("contact_preference").default("email"),
	notes: text().default(""),
	source: text().default("website"),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
},
(table) => [
	uniqueIndex("customer_profiles_customer_number_unique").on(table.customerNumber),
]);

export const customerTagAssignments = sqliteTable("customer_tag_assignments", {
	id: text().primaryKey().notNull(),
	customerProfileId: text("customer_profile_id").references(() => customerProfiles.id, { onDelete: "cascade" } ),
	customerTagId: text("customer_tag_id").references(() => customerTags.id, { onDelete: "cascade" } ),
	assignedBy: text("assigned_by"),
	assignedAt: integer("assigned_at"),
});

export const customerTags = sqliteTable("customer_tags", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	color: text().default("#6B7280"),
	description: text(),
	category: text().default("custom"),
	isSystem: integer("is_system").default(false),
	createdAt: integer("created_at"),
},
(table) => [
	uniqueIndex("customer_tags_name_unique").on(table.name),
]);

export const newsletters = sqliteTable("newsletters", {
	id: text().primaryKey().notNull(),
	email: text().notNull(),
	status: text().default("active"),
	source: text().default("website"),
	createdAt: integer("created_at"),
},
(table) => [
	uniqueIndex("newsletters_email_unique").on(table.email),
]);

export const orders = sqliteTable("orders", {
	id: text().primaryKey().notNull(),
	orderNumber: text("order_number").notNull(),
	userId: text("user_id").references(() => users.id),
	customerInfo: text("customer_info").notNull(),
	items: text().notNull(),
	subtotalAmount: real("subtotal_amount").notNull(),
	shippingFee: real("shipping_fee"),
	totalAmount: real("total_amount").notNull(),
	paymentMethod: text("payment_method").default("bank_transfer"),
	status: text().default("pending_payment"),
	paymentStatus: text("payment_status").default("unpaid"),
	paymentProof: text("payment_proof"),
	paymentVerifiedAt: integer("payment_verified_at"),
	paymentVerifiedBy: text("payment_verified_by"),
	notes: text().default(""),
	adminNotes: text("admin_notes").default(""),
	shippingAddress: text("shipping_address"),
	trackingNumber: text("tracking_number"),
	shippingCompany: text("shipping_company"),
	shippedAt: integer("shipped_at"),
	deliveredAt: integer("delivered_at"),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
},
(table) => [
	uniqueIndex("orders_order_number_unique").on(table.orderNumber),
]);

export const products = sqliteTable("products", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	slug: text().notNull(),
	description: text().notNull(),
	category: text().notNull(),
	images: text().default("[]").notNull(),
	variants: text().default("[]").notNull(),
	features: text().default("[]").notNull(),
	specifications: text().default("{}").notNull(),
	inStock: integer("in_stock").default(true),
	featured: integer().default(false),
	sortOrder: integer("sort_order").default(0),
	seoTitle: text("seo_title"),
	seoDescription: text("seo_description"),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
},
(table) => [
	uniqueIndex("products_slug_unique").on(table.slug),
]);

export const reviews = sqliteTable("reviews", {
	id: text().primaryKey().notNull(),
	customerName: text("customer_name").notNull(),
	productId: text("product_id").references(() => products.id),
	rating: integer().notNull(),
	content: text().notNull(),
	source: text().default("website"),
	verified: integer().default(false),
	featured: integer().default(false),
	createdAt: integer("created_at"),
});

export const sessions = sqliteTable("sessions", {
	id: text().primaryKey().notNull(),
	expiresAt: integer("expires_at").notNull(),
	token: text().notNull(),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
},
(table) => [
	uniqueIndex("sessions_token_unique").on(table.token),
]);

export const users = sqliteTable("users", {
	id: text().primaryKey().notNull(),
	name: text(),
	email: text().notNull(),
	emailVerified: integer("email_verified").default(false),
	image: text(),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
	phone: text(),
	role: text().default("customer"),
	preferences: text().default("{}"),
},
(table) => [
	uniqueIndex("users_email_unique").on(table.email),
]);

export const verifications = sqliteTable("verifications", {
	id: text().primaryKey().notNull(),
	identifier: text().notNull(),
	value: text().notNull(),
	expiresAt: integer("expires_at").notNull(),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
});

export const customerAddresses = sqliteTable("customer_addresses", {
	id: text().primaryKey().notNull(),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
	type: text().notNull(),
	label: text(),
	isDefault: integer("is_default").default(false),
	recipientName: text("recipient_name").notNull(),
	recipientPhone: text("recipient_phone").notNull(),
	city: text().notNull(),
	district: text().notNull(),
	postalCode: text("postal_code").notNull(),
	street: text().notNull(),
	building: text(),
	floor: text(),
	room: text(),
	deliveryInstructions: text("delivery_instructions"),
	accessCode: text("access_code"),
	lastUsedAt: integer("last_used_at"),
	usageCount: integer("usage_count").default(0),
	isActive: integer("is_active").default(true),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
});

export const customerNotificationPreferences = sqliteTable("customer_notification_preferences", {
	id: text().primaryKey().notNull(),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
	emailOrderUpdates: integer("email_order_updates").default(true),
	emailAppointmentReminders: integer("email_appointment_reminders").default(true),
	emailNewsletters: integer("email_newsletters").default(true),
	emailPromotions: integer("email_promotions").default(true),
	emailPriceAlerts: integer("email_price_alerts").default(true),
	emailProductRecommendations: integer("email_product_recommendations").default(false),
	smsOrderUpdates: integer("sms_order_updates").default(false),
	smsAppointmentReminders: integer("sms_appointment_reminders").default(true),
	smsPromotions: integer("sms_promotions").default(false),
	smsDeliveryUpdates: integer("sms_delivery_updates").default(true),
	pushOrderUpdates: integer("push_order_updates").default(true),
	pushAppointmentReminders: integer("push_appointment_reminders").default(true),
	pushPromotions: integer("push_promotions").default(false),
	emailFrequency: text("email_frequency").default("immediate"),
	smsFrequency: text("sms_frequency").default("important_only"),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
});

export const customerPaymentMethods = sqliteTable("customer_payment_methods", {
	id: text().primaryKey().notNull(),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
	type: text().notNull(),
	provider: text(),
	cardToken: text("card_token"),
	lastFourDigits: text("last_four_digits"),
	expiryMonth: text("expiry_month"),
	expiryYear: text("expiry_year"),
	cardholderName: text("cardholder_name"),
	bankName: text("bank_name"),
	bankCode: text("bank_code"),
	accountType: text("account_type"),
	accountLastFour: text("account_last_four"),
	walletProvider: text("wallet_provider"),
	walletAccountId: text("wallet_account_id"),
	isDefault: integer("is_default").default(false),
	isActive: integer("is_active").default(true),
	nickname: text(),
	encryptionKeyId: text("encryption_key_id"),
	lastUsedAt: integer("last_used_at"),
	usageCount: integer("usage_count").default(0),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
});

export const customerRecentlyViewed = sqliteTable("customer_recently_viewed", {
	id: text().primaryKey().notNull(),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
	productId: text("product_id").notNull().references(() => products.id, { onDelete: "cascade" } ),
	viewedAt: integer("viewed_at"),
	viewDurationSeconds: integer("view_duration_seconds"),
	referrerUrl: text("referrer_url"),
	deviceType: text("device_type"),
	createdAt: integer("created_at"),
});

export const customerReviews = sqliteTable("customer_reviews", {
	id: text().primaryKey().notNull(),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
	productId: text("product_id").notNull().references(() => products.id, { onDelete: "cascade" } ),
	orderId: text("order_id").references(() => orders.id),
	rating: integer().notNull(),
	title: text().notNull(),
	content: text().notNull(),
	pros: text().default("[]"),
	cons: text().default("[]"),
	images: text().default("[]"),
	status: text().default("pending"),
	moderatedBy: text("moderated_by"),
	moderatedAt: integer("moderated_at"),
	moderationNotes: text("moderation_notes"),
	helpfulCount: integer("helpful_count").default(0),
	totalVotes: integer("total_votes").default(0),
	verified: integer().default(false),
	purchaseDate: integer("purchase_date"),
	featured: integer().default(false),
	displayName: text("display_name"),
	showFullName: integer("show_full_name").default(false),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
});

export const customerWishlists = sqliteTable("customer_wishlists", {
	id: text().primaryKey().notNull(),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
	productId: text("product_id").notNull().references(() => products.id, { onDelete: "cascade" } ),
	variantId: text("variant_id"),
	notes: text(),
	priority: text().default("medium"),
	priceAlert: real("price_alert"),
	addedAt: integer("added_at"),
	lastViewedAt: integer("last_viewed_at"),
	viewCount: integer("view_count").default(1),
});

export const userSecurity = sqliteTable("user_security", {
	id: text().primaryKey().notNull(),
	userId: text("user_id").notNull().references(() => users.id, { onDelete: "cascade" } ),
	passwordHash: text("password_hash"),
	passwordSalt: text("password_salt"),
	passwordLastChanged: integer("password_last_changed"),
	forcePasswordChange: integer("force_password_change").default(false),
	lastLoginAt: integer("last_login_at"),
	lastLoginIp: text("last_login_ip"),
	lastLoginUserAgent: text("last_login_user_agent"),
	loginCount: integer("login_count").default(0),
	twoFactorEnabled: integer("two_factor_enabled").default(false),
	twoFactorSecret: text("two_factor_secret"),
	backupCodes: text("backup_codes").default("[]"),
	isLocked: integer("is_locked").default(false),
	lockedAt: integer("locked_at"),
	lockedReason: text("locked_reason"),
	failedLoginAttempts: integer("failed_login_attempts").default(0),
	lastFailedLoginAt: integer("last_failed_login_at"),
	allowDataCollection: integer("allow_data_collection").default(true),
	allowMarketing: integer("allow_marketing").default(true),
	allowSmsMarketing: integer("allow_sms_marketing").default(false),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
});

export const postCategories = sqliteTable("post_categories", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	slug: text().notNull(),
	description: text(),
	color: text().default("#6B7280"),
	icon: text(),
	isActive: integer("is_active").default(true),
	sortOrder: integer("sort_order").default(0),
	seoTitle: text("seo_title"),
	seoDescription: text("seo_description"),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
},
(table) => [
	uniqueIndex("post_categories_slug_unique").on(table.slug),
	uniqueIndex("post_categories_name_unique").on(table.name),
]);

export const posts = sqliteTable("posts", {
	id: text().primaryKey().notNull(),
	title: text().notNull(),
	slug: text().notNull(),
	description: text().notNull(),
	content: text().notNull(),
	excerpt: text(),
	authorId: text("author_id").references(() => users.id),
	authorName: text("author_name"),
	status: text().default("draft"),
	featured: integer().default(false),
	categoryId: text("category_id").references(() => postCategories.id),
	category: text().default("部落格文章"),
	tags: text().default("[]"),
	featuredImage: text("featured_image"),
	seoTitle: text("seo_title"),
	seoDescription: text("seo_description"),
	seoKeywords: text("seo_keywords").default("[]"),
	canonicalUrl: text("canonical_url"),
	ogTitle: text("og_title"),
	ogDescription: text("og_description"),
	ogImage: text("og_image"),
	publishedAt: integer("published_at"),
	scheduledAt: integer("scheduled_at"),
	viewCount: integer("view_count").default(0),
	readingTime: integer("reading_time").default(5),
	allowComments: integer("allow_comments").default(true),
	sortOrder: integer("sort_order").default(0),
	createdAt: integer("created_at"),
	updatedAt: integer("updated_at"),
},
(table) => [
	uniqueIndex("posts_slug_unique").on(table.slug),
]);

