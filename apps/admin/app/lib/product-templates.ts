import type { ProductTypeTemplate, VariantAxis, ProductOptions } from '@blackliving/types';
import {
  PRODUCT_TYPE_TEMPLATES,
  getProductTypeTemplate,
  getAllProductTypeTemplates,
  validateProductTypeTemplate,
  getTemplateByCategory,
  getRequiredVariantAxes,
  generateVariantCombinations,
} from '@blackliving/types';

// Re-export everything for convenience
export {
  PRODUCT_TYPE_TEMPLATES,
  getProductTypeTemplate,
  getAllProductTypeTemplates,
  validateProductTypeTemplate,
  getTemplateByCategory,
  getRequiredVariantAxes,
  generateVariantCombinations,
};

export type { ProductTypeTemplate, VariantAxis, ProductOptions };

// Admin-specific utility functions
export function getProductTypeOptions() {
  return Object.entries(PRODUCT_TYPE_TEMPLATES).map(([_key, template]) => ({
    value: template.id,  // Use template.id (e.g., 'sheet-set') instead of object key ('sheetSet')
    label: template.name,
    category: template.category,
  }));
}

export function getCategoryProductTypes(category: string) {
  return getTemplateByCategory(category).map(template => ({
    value: template.id,
    label: template.name,
  }));
}

export function validateProductAgainstTemplate(
  productType: string,
  productData: any
): { isValid: boolean; errors: Record<string, string> } {
  const template = getProductTypeTemplate(productType);
  if (!template) {
    return { isValid: false, errors: { productType: `Unknown product type: ${productType}` } };
  }

  const errors: Record<string, string> = {};

  // Check required fields
  for (const field of template.requiredFields) {
    if (!productData[field]) {
      errors[field] = `${field} is required for ${template.name}`;
    }
  }

  // Validate variant axes if variants exist
  if (productData.variants && productData.variants.length > 0) {
    const requiredAxes = getRequiredVariantAxes(template);
    for (let i = 0; i < productData.variants.length; i++) {
      const variant = productData.variants[i];
      for (const axis of requiredAxes) {
        const axisValue = variant[axis.type] || variant.optionValues?.[axis.id];
        if (!axisValue) {
          errors[`variants.${i}.${axis.type}`] = `${axis.name} is required`;
        } else if (!axis.values.includes(axisValue)) {
          errors[`variants.${i}.${axis.type}`] = `Invalid ${axis.name}: "${axisValue}". Must be one of: ${axis.values.join(', ')}`;
        }
      }
    }
  }

  return { isValid: Object.keys(errors).length === 0, errors };
}

export function generateDefaultVariants(productType: string): any[] {
  const template = getProductTypeTemplate(productType);
  if (!template) return [];

  const combinations = generateVariantCombinations(template);
  return combinations.map((combo, index) => ({
    id: `variant-${index + 1}`,
    name: Object.values(combo).join(' - '),
    sku: '', // Will be generated by SKU utility
    price: 0,
    originalPrice: undefined,
    stock: 0,
    inStock: true,
    sortOrder: index,
    optionValues: combo,
    ...combo, // Spread for backward compatibility
  }));
}

export function getTemplateDisplayName(productType: string): string {
  const template = getProductTypeTemplate(productType);
  return template ? template.name : productType;
}

export function getTemplateCategory(productType: string): string {
  const template = getProductTypeTemplate(productType);
  return template ? template.category : 'unknown';
}
