import type { ProductTypeTemplate, VariantAxis, ProductOptions } from '@blackliving/types';
import {
  PRODUCT_TYPE_TEMPLATES,
  getProductTypeTemplate,
  getAllProductTypeTemplates,
  validateProductTypeTemplate,
  getTemplateByCategory,
  getRequiredVariantAxes,
  generateVariantCombinations,
} from '@blackliving/types';

// Re-export everything for convenience
export {
  PRODUCT_TYPE_TEMPLATES,
  getProductTypeTemplate,
  getAllProductTypeTemplates,
  validateProductTypeTemplate,
  getTemplateByCategory,
  getRequiredVariantAxes,
  generateVariantCombinations,
};

export type { ProductTypeTemplate, VariantAxis, ProductOptions };

// Admin-specific utility functions
export function getProductTypeOptions() {
  return Object.entries(PRODUCT_TYPE_TEMPLATES).map(([id, template]) => ({
    value: id,
    label: template.name,
    category: template.category,
  }));
}

export function getCategoryProductTypes(category: string) {
  return getTemplateByCategory(category).map(template => ({
    value: template.id,
    label: template.name,
  }));
}

export function validateProductAgainstTemplate(
  productType: string,
  productData: any
): { isValid: boolean; errors: string[] } {
  const template = getProductTypeTemplate(productType);
  if (!template) {
    return { isValid: false, errors: [`Unknown product type: ${productType}`] };
  }

  const errors: string[] = [];

  // Check required fields
  for (const field of template.requiredFields) {
    if (!productData[field]) {
      errors.push(`Missing required field: ${field}`);
    }
  }

  // Validate variant axes if variants exist
  if (productData.variants && productData.variants.length > 0) {
    const requiredAxes = getRequiredVariantAxes(template);
    for (const variant of productData.variants) {
      for (const axis of requiredAxes) {
        const axisValue = variant[axis.type] || variant.optionValues?.[axis.id];
        if (!axisValue) {
          errors.push(`Variant missing required ${axis.name} (${axis.type})`);
        } else if (!axis.values.includes(axisValue)) {
          errors.push(`Invalid ${axis.name} value: ${axisValue}. Must be one of: ${axis.values.join(', ')}`);
        }
      }
    }
  }

  return { isValid: errors.length === 0, errors };
}

export function generateDefaultVariants(productType: string): any[] {
  const template = getProductTypeTemplate(productType);
  if (!template) return [];

  const combinations = generateVariantCombinations(template);
  return combinations.map((combo, index) => ({
    id: `variant-${index + 1}`,
    name: Object.values(combo).join(' - '),
    sku: '', // Will be generated by SKU utility
    price: 0,
    originalPrice: undefined,
    stock: 0,
    inStock: true,
    sortOrder: index,
    optionValues: combo,
    ...combo, // Spread for backward compatibility
  }));
}

export function getTemplateDisplayName(productType: string): string {
  const template = getProductTypeTemplate(productType);
  return template ? template.name : productType;
}

export function getTemplateCategory(productType: string): string {
  const template = getProductTypeTemplate(productType);
  return template ? template.category : 'unknown';
}
