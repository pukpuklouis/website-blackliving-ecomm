---
import BaseLayout from '../../../layouts/BaseLayout.astro';
import CTA from '../../../components/CTA.astro';
import BlogPostCard from '../../../components/BlogPostCard.astro';
import type { BlogPost, BlogPostSummary, PostCategory } from '@blackliving/types';

interface StaticCategory extends PostCategory {
  postsCount?: number;
}

const apiUrl = import.meta.env.PUBLIC_API_BASE_URL || 'http://localhost:8787';

const fallbackCategories: StaticCategory[] = [
  {
    id: 'cat_001',
    slug: 'blog-post',
    name: 'å¥½æ–‡åˆ†äº«',
    description: 'ç¡çœ çŸ¥è­˜èˆ‡å¥åº·ç”Ÿæ´»åˆ†äº«ï¼Œå°ˆæ¥­åºŠå¢Šé¸è³¼æŒ‡å—èˆ‡ä½¿ç”¨å¿ƒå¾—',
    color: '#1f2937',
    icon: 'ğŸ›ï¸',
    postsCount: 0,
  },
  {
    id: 'cat_002',
    slug: 'customer-reviews',
    name: 'éƒ¨è½æ ¼æ¨è–¦',
    description: 'ä¾†è‡ªçœŸå¯¦å®¢æˆ¶çš„ç¡çœ é«”é©—åˆ†äº«ï¼Œäº†è§£ Simmons é»‘ç‰ŒåºŠå¢Šçš„å¯¦éš›ä½¿ç”¨å¿ƒå¾—èˆ‡è©•åƒ¹',
    color: '#10B981',
    icon: 'â­',
    postsCount: 0,
  },
];

function normalizeCategorySlug(value?: string | null): string {
  if (!value) return 'blog-post';
  const input = value.trim().toLowerCase();
  if (['customer-reviews', 'éƒ¨è½æ ¼æ¨è–¦', 'å®¢æˆ¶è©•åƒ¹'].includes(input)) {
    return 'customer-reviews';
  }
  if (['blog-post', 'å¥½æ–‡åˆ†äº«', 'éƒ¨è½æ ¼æ–‡ç« ', 'blog'].includes(input)) {
    return 'blog-post';
  }
  if (input.startsWith('cat_')) {
    if (input === 'cat_002') return 'customer-reviews';
    if (input === 'cat_001') return 'blog-post';
    return input.slice(4);
  }
  return input.replace(/\s+/g, '-');
}

function resolveCategoryName(slug: string, fallback?: string): string {
  if (slug === 'customer-reviews') return 'éƒ¨è½æ ¼æ¨è–¦';
  if (slug === 'blog-post') return 'å¥½æ–‡åˆ†äº«';
  return fallback || slug;
}

function resolveCategoryDescription(slug: string, fallback?: string): string {
  if (fallback) return fallback;
  if (slug === 'customer-reviews') {
    return 'ä¾†è‡ªçœŸå¯¦å®¢æˆ¶çš„ç¡çœ é«”é©—åˆ†äº«ï¼Œäº†è§£ Simmons é»‘ç‰ŒåºŠå¢Šçš„å¯¦éš›ä½¿ç”¨å¿ƒå¾—èˆ‡è©•åƒ¹';
  }
  if (slug === 'blog-post') {
    return 'ç¡çœ çŸ¥è­˜èˆ‡å¥åº·ç”Ÿæ´»åˆ†äº«ï¼Œå°ˆæ¥­åºŠå¢Šé¸è³¼æŒ‡å—èˆ‡ä½¿ç”¨å¿ƒå¾—';
  }
  return '';
}

function isPostCategory(data: any): data is PostCategory {
  return (
    data &&
    typeof data === 'object' &&
    typeof data.id === 'string' &&
    typeof data.slug === 'string' &&
    typeof data.name === 'string'
  );
}

export async function getStaticPaths() {
  try {
    const response = await fetch(`${apiUrl}/api/posts/categories`);
    if (response.ok) {
      const payload = await response.json();
      const categories = Array.isArray(payload?.data) ? payload.data : [];

      if (categories.length > 0) {
        return categories
          .map((category: any) => {
            if (!category?.slug && !category?.name) return null;
            const slug = normalizeCategorySlug(category.slug || category.name);
            return {
              params: { post_category: slug },
              props: {
                category: {
                  id: category.id,
                  slug,
                  name: category.name,
                  description: category.description,
                  color: category.color,
                  icon: category.icon,
                  postsCount: category.postsCount,
                } satisfies StaticCategory,
              },
            };
          })
          .filter(Boolean);
      }
    } else {
      console.error('Failed to fetch post categories for static paths:', response.status);
    }
  } catch (error) {
    console.error('Error fetching post categories for static paths:', error);
  }

  // Inline fallbacks to avoid any scope issues in dev/build
  return [
    {
      params: { post_category: 'blog-post' },
      props: {
        category: {
          id: 'cat_001',
          slug: 'blog-post',
          name: 'å¥½æ–‡åˆ†äº«',
          description: 'ç¡çœ çŸ¥è­˜èˆ‡å¥åº·ç”Ÿæ´»åˆ†äº«ï¼Œå°ˆæ¥­åºŠå¢Šé¸è³¼æŒ‡å—èˆ‡ä½¿ç”¨å¿ƒå¾—',
          color: '#1f2937',
          icon: 'ğŸ›ï¸',
          postsCount: 0,
        },
      },
    },
    {
      params: { post_category: 'simmons-knowledge' },
      props: {
        category: {
          id: 'cat_003',
          slug: 'simmons-knowledge',
          name: 'å¸­å¤¢æ€å°çŸ¥è­˜',
          description: 'åˆ†äº«å¸­å¤¢æ€çš„ç›¸é—œå°çŸ¥è­˜',
          color: '#6B7280',
          icon: 'â„¹ï¸',
          postsCount: 0,
        },
      },
    },
    {
      params: { post_category: 'customer-reviews' },
      props: {
        category: {
          id: 'cat_002',
          slug: 'customer-reviews',
          name: 'éƒ¨è½æ ¼æ¨è–¦',
          description: 'ä¾†è‡ªçœŸå¯¦å®¢æˆ¶çš„ç¡çœ é«”é©—åˆ†äº«ï¼Œäº†è§£ Simmons é»‘ç‰ŒåºŠå¢Šçš„å¯¦éš›ä½¿ç”¨å¿ƒå¾—èˆ‡è©•åƒ¹',
          color: '#10B981',
          icon: 'â­',
          postsCount: 0,
        },
      },
    },
  ];
}

// Conditional prerender: disabled in dev for easier preview, enabled in staging/production for static generation
export const prerender = import.meta.env.MODE !== 'development';

interface Props {
  category?: StaticCategory;
}

interface Params extends Record<string, string> {
  post_category: string;
}

const params = Astro.params as Params;
const { category: staticCategory } = Astro.props as Props;
const routeCategorySlug = normalizeCategorySlug(params.post_category);

let category = staticCategory ?? null;

if (!category) {
  try {
    const categoryResponse = await fetch(`${apiUrl}/api/posts/categories/${routeCategorySlug}`);
    if (categoryResponse.ok) {
      const categoryPayload = await categoryResponse.json();
      if (categoryPayload?.success && categoryPayload?.data) {
        category = {
          id: categoryPayload.data.id,
          slug: normalizeCategorySlug(categoryPayload.data.slug),
          name: categoryPayload.data.name,
          description: categoryPayload.data.description,
          color: categoryPayload.data.color,
          icon: categoryPayload.data.icon,
          postsCount: categoryPayload.data.postsCount,
        };
      }
    }
  } catch (error) {
    console.error('Error fetching category detail:', error);
  }
}

if (!category) {
  const fallback = fallbackCategories.find((item) => item.slug === routeCategorySlug);
  if (fallback) {
    category = fallback;
  } else {
    throw new Error(`Post category not found for slug: ${routeCategorySlug}`);
  }
}

const categorySlug = normalizeCategorySlug(category.slug);
const categoryName = resolveCategoryName(categorySlug, category.name);
const categoryDescription = resolveCategoryDescription(categorySlug, category.description);

let rawPosts: (BlogPost & { category?: PostCategory | string })[] = [];

try {
  const postsResponse = await fetch(
    `${apiUrl}/api/posts/public?category=${encodeURIComponent(categorySlug)}&include=category`
  );

  if (postsResponse.ok) {
    const postsPayload = await postsResponse.json();

    rawPosts = Array.isArray(postsPayload?.data) ? postsPayload.data : [];
  } else {
    console.warn(`Failed to fetch posts for category "${categorySlug}":`, postsResponse.status);
  }
} catch (error) {
  console.error('Error fetching posts for category:', error);
}

const posts: BlogPostSummary[] = rawPosts.map((post) => {
  const categoryData = post.category;
  let slugSource: string | undefined;
  let categoryLabel: string;

  if (isPostCategory(categoryData)) {
    slugSource = categoryData.slug || categoryData.id;
    categoryLabel = categoryData.name || resolveCategoryName(normalizeCategorySlug(slugSource));
  } else if (typeof categoryData === 'string') {
    slugSource = categoryData;
    categoryLabel = resolveCategoryName(normalizeCategorySlug(slugSource), categoryData);
  } else {
    slugSource = undefined;
    categoryLabel = resolveCategoryName('');
  }

  return {
    slug: post.slug,
    title: post.title,
    excerpt: post.excerpt,
    description: post.description,
    featuredImage: post.featuredImage,
    category: categoryLabel,
    authorName: post.authorName,
    publishedAt: post.publishedAt,
  };
});

const cardVariant = categorySlug === 'customer-reviews' ? 'vertical' : 'horizontal';
const pageTitle = `${categoryName} - Black Living é»‘å“¥å®¶å±…`;
const pageDescription = categoryDescription || 'æœ€æ–°æ–‡ç« èˆ‡å“ç‰Œæ•…äº‹åˆ†äº«';
---

<BaseLayout title={pageTitle} description={pageDescription}>
  <main class="container mx-auto px-4 py-8 mb-12">
    <div class="text-center mb-12">
      <h1 class="text-4xl font-bold text-gray-900 mb-4">{categoryName}</h1>
      {categoryDescription && <p class="text-xl text-gray-600">{categoryDescription}</p>}
    </div>

    <div class="max-w-4xl mx-auto">
      <div
        class={`grid grid-cols-1 ${cardVariant === 'vertical' ? 'md:grid-cols-2 gap-8' : 'md:flex flex-col gap-8'}`}
      >
        {
          posts.map((post) => (
            <BlogPostCard
              post={post}
              variant={cardVariant}
              href={`/blog/${categorySlug}/${post.slug}`}
            />
          ))
        }
      </div>
      {
        posts.length === 0 && (
          <div class="text-center py-12">
            <p class="text-gray-500">ç›®å‰å°šç„¡æ–‡ç« ...</p>
          </div>
        )
      }
    </div>
  </main>
  <CTA />
</BaseLayout>
