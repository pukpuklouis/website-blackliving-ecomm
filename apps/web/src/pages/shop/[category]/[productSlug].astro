---
import ProductDetail from "../../../components/ProductDetail.tsx";
import ProductImageCarousel from "../../../components/ProductImageCarousel.tsx";
import ProductTabs from "../../../components/ProductTabs.tsx";
import ProductLayout from "../../../layouts/ProductLayout.astro";
import type { CategoryConfig } from "../../../types/category.ts";
import {
  fetchCategoryConfig,
  fetchProduct,
  generateProductStaticPaths,
} from "../../../utils/productPaths.ts";

type StaticProps = {
  categoryConfig?: CategoryConfig;
};

export async function getStaticPaths() {
  return await generateProductStaticPaths();
}

const { category, productSlug } = Astro.params;
const { categoryConfig: prefetchedCategory } =
  (Astro.props as StaticProps) ?? {};

const {
  categoryConfig,
  error: categoryError,
  notFound: categoryNotFound,
} = await fetchCategoryConfig(category, prefetchedCategory);

if (categoryNotFound || !categoryConfig) {
  throw new Response(null, { status: 404 });
}

const {
  product,
  error: productError,
  notFound: productNotFound,
} = await fetchProduct(productSlug);

if (productNotFound || !product || productError) {
  console.log(
    `DEBUG: Throwing 404 for productSlug "${productSlug}". productNotFound: ${productNotFound}, product: ${!!product}, productError: ${productError}`
  );
  throw new Response(null, { status: 404 });
}

if (product.category !== categoryConfig.slug) {
  console.warn(
    `Product slug "${productSlug}" does not match category "${categoryConfig.slug}"; returning 404.`
  );
  throw new Response(null, { status: 404 });
}

if (categoryError) {
  console.warn(`Category fallback used for slug "${category}":`, categoryError);
}

// Build Product structured data with required offers
const siteUrl = Astro.site?.toString() || "https://www.blackliving.tw";
const productUrl = new URL(
  `/shop/${categoryConfig.slug}/${product.slug}`,
  siteUrl
).toString();
const productImage = product.images?.[0]
  ? new URL(product.images[0], siteUrl).toString()
  : undefined;

// Calculate price range from variants
const prices = (product.variants || [])
  .map((v: { price?: number }) => v.price)
  .filter(
    (p: number | undefined): p is number => typeof p === "number" && p > 0
  );
const lowestPrice = prices.length > 0 ? Math.min(...prices) : null;
const highestPrice = prices.length > 0 ? Math.max(...prices) : null;

// Build offers - use AggregateOffer if multiple prices, otherwise single Offer
function buildOffers(
  minPrice: number | null,
  maxPrice: number | null,
  priceCount: number,
  isInStock: boolean
) {
  const availability = isInStock
    ? "https://schema.org/InStock"
    : "https://schema.org/OutOfStock";

  if (minPrice === null) {
    return {
      "@type": "Offer",
      price: 0,
      priceCurrency: "TWD",
      availability: "https://schema.org/PreOrder",
      priceValidUntil: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000)
        .toISOString()
        .split("T")[0],
    };
  }

  if (minPrice !== maxPrice && maxPrice !== null) {
    return {
      "@type": "AggregateOffer",
      lowPrice: minPrice,
      highPrice: maxPrice,
      priceCurrency: "TWD",
      availability,
      offerCount: priceCount,
    };
  }

  return {
    "@type": "Offer",
    price: minPrice,
    priceCurrency: "TWD",
    availability,
  };
}

const offers = buildOffers(
  lowestPrice,
  highestPrice,
  prices.length,
  product.inStock !== false
);

const productSchema = {
  "@context": "https://schema.org",
  "@type": "Product",
  name: product.name,
  description:
    product.description || `${categoryConfig.series} - ${product.name}`,
  image: productImage,
  url: productUrl,
  brand: {
    "@type": "Brand",
    name: categoryConfig.brand || "席夢思 Simmons",
  },
  category: categoryConfig.series,
  offers,
};

// Conditional prerender: disabled in dev for easier preview, enabled in staging/production for static generation
export const prerender = import.meta.env.MODE !== "development";
---

{product && (
    <ProductLayout
      title={product.name}
      description={product.description}
      image={product.images?.[0]}
      productSchema={productSchema}
    >
      <ProductImageCarousel
        images={product.images || []}
        productName={product.name}
        client:load
        slot="product-images"
      />

      <div slot="product-details">
        <ProductDetail
          product={product}
          categoryConfig={categoryConfig}
          className="mt-6"
          client:load
        />

        <div class="mt-8 lg:hidden">
          <ProductTabs
            features={product.features || []}
            categoryFeatures={categoryConfig.features}
            categoryName={categoryConfig.series}
            featuresMarkdown={product.featuresMarkdown}
            client:load
          />
        </div>
      </div>

      <div class="hidden lg:block" slot="product-tabs">
        <ProductTabs
          features={product.features || []}
          categoryFeatures={categoryConfig.features}
          categoryName={categoryConfig.series}
          featuresMarkdown={product.featuresMarkdown}
          client:load
        />
      </div>
    </ProductLayout>
  )}
